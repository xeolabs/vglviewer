/* Generated by Together */

package vglDocument.utils;

import vglDocument.VGLDocument;
import vglDocument.AbstractVGLFontFactory;

public class VGLDocumentBuilder {
    /** Creates new builder, which so far has an empty document. */
    public VGLDocumentBuilder(ErrorHandler errorHandler, AbstractVGLFontFactory fontManager) {
        this.errorHandler = errorHandler;
        this.logger = null;
        this.toLog = false;
        this.fontManager = fontManager;
        reset();
    }

    private void reset() {
        context = new BuildContext(new VGLDocument(), errorHandler, fontManager);
        state = new BuildingDocument(context);
    }

    /**
     *Specifies a logger to get log messages
     * @param logger the logger
     */
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    /** Print a trace message */
    private void log(String message) {
        if (logger != null) {
            StringBuffer sb = new StringBuffer("Document builder: ");
            for (int i = 0; i < traceIndent; i += 4) {
                sb.append("   ");
            }
            sb.append(message);
            logger.log(sb.toString());
        }
    }

    /** Reset builder to initial state, in which it has an empty, unbuilt document */
    public void newDocument() {
        if (logger != null) {
            log("starting new document");
        }
        reset();
    }

    /** Open a new style definition */
    public void openStyle() {
        tryOpen(state.openStyle());
    }

    /** Set name of currently open element */
    public void setName(String name) {
        if (logger != null) {
            log("setting name");
        }
        state.setName(name);
    }

    /** Set stroke colour for currently open style definition */
    public void setStrokeColor(int r, int g, int b) {
        if (logger != null) {
            log("setting stroke color");
        }
        state.setStrokeColor(r, g, b);
    }

    /** Set fill colour for currently open style definition */
    public void setFillColor(int r, int g, int b) {
        if (logger != null) {
            log("setting fill color");
        }
        state.setFillColor(r, g, b);
    }

    /** Set font for currently open style definition */
    public void setFont(String face, int style, int size) {
        if (logger != null) {
            log("setting font");
        }
        state.setFont(face, style, size);
    }

    /** Open a new polygon element */
    public void openPolygon() {
        tryOpen(state.openPolygon());
    }

    /** Open a new path element */
    public void openPath() {
        tryOpen(state.openPath());
    }

    /** Open a new text element */
    public void openText() {
        tryOpen(state.openText());
    }

    /** Sets value of text element */
    public void setText(String text) {
        if (logger != null) {
            log("setting text: '" + text + "'");
        }
        state.setText(text);
    }

    /** Sets origin of element */
    public void setOrigin(long x, long y) {
        if (logger != null) {
            log("setting origin: (" + x + "," + y + ")");
        }
        state.setOrigin(x, y);
    }

    /** Open a new circle */
    public void openCircle() {
        tryOpen(state.openCircle());
    }

    /** Sets centre of element */
    public void setCentre(long x, long y) {
        if (logger != null) {
            log("setting centre: (" + x + "," + y + ")");
        }
        state.setCentre(x, y);
    }

    /** Sets radius of element */
    public void setRadius(long r) {
        if (logger != null) {
            log("setting radius: " + r + ")");
        }
        state.setRadius(r);
    }

    /** Apply a style (that was defined ealier) to the currently open element */
    public void applyStyle(String styleName) {
        if (logger != null) {
            log("applying style '" + styleName + "'");
        }
        state.applyStyle(styleName);
    }

    /** Add a vertex to the currently open element */
    public void addVertex(long x, long y) {
        if (logger != null) {
            log("adding vertex " + x + "," + y);
        }
        state.addVertex(x, y);
    }

    /** Convenience method, sets current builder state to given and prints trace message */
    private void tryOpen(AbstractBuilderState newState) {
        state = newState;
        if (logger != null) {
            log("opened " + state.getDescription());
            traceIndent++;
        }
    }

    /** Close the currently open element */
    public void close() {
        if (logger != null) {
            traceIndent--;
            log("closed " + state.getDescription());
        }
        if (state instanceof BuildingDocument) {
            errorHandler.handleError("document not open");
            return;
        }
        state = state.close();
    }

    /** Build the document */
    public VGLDocument buildDocument() {
        if (logger != null) {
            traceIndent--;
            log("finishing document");
        }
        if (!(state instanceof BuildingDocument)) {
            errorHandler.handleError("document not finished - " + state.getDescription() + " not closed");
        }
        return context.getDocument();
    }

    /** @supplierRole state 
     * @clientCardinality 1
     * @supplierCardinality 1*/
    private AbstractBuilderState state;

    /**
     * @supplierCardinality 1
     * @clientCardinality 1 
     */
    private BuildContext context;

    /**
     * @supplierCardinality 1
     * @clientCardinality 1 
     */
    private ErrorHandler errorHandler;

    /**
     * @clientCardinality 1
     * @supplierCardinality 1 
     */
    private Logger logger;
    private boolean toLog;
    private int traceIndent;
    private AbstractVGLFontFactory fontManager;
}
