<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><title>vglDocument.utils</title><link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style"></head><body><table style="text-align: left; width: 100%; height: 100%;" border="0" cellspacing="0" cellpadding="6"><tbody><tr><td style="text-align: right; background-color: rgb(200, 200, 200);"></td><td class="navGlobal"><font class="navGlobal"><a href="siteIndex.html">Index</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="bibliography.html">Bibliography</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generated by&nbsp;<a href="about/about.html">SiteGen V1.0</a></font></td></tr><tr><td style="text-align: right;  background-color: rgb(0, 0, 0);"><center><img src="logo.gif"/></center></td><td style="height: 100px; vertical-align: bottom; background-color: rgb(255, 255, 100); white-space: nowrap;"><font class="pageTitle">vglDocument.utils</font><br><font class="pageDescription">Utilities for building and loading VGL documents</font><br><br></td></tr><tr><td class="navTitle"><font class="sectionTitle">Navigation</font></td><td style="vertical-align: top;"><font class="sectionTitle">Document</font></td></tr><tr><td class="navPath"><br><font class="navPrevious"><a href="index.html">VGLViewer</a></font><br><img src="downArrow.gif"/><br><font class="navPrevious"><a href="page1.html">Implementation</a></font><br><img src="downArrow.gif"/><br><font class="navCurrent">vglDocument.utils</font></td><td style = "vertical-align: top;"><br><br><font class="normalText"><div style="margin-left: 40px;"><a href="#Introduction">Introduction</a></div><div style="margin-left: 40px;"><a href="#VGLDocumentBuilder:_a_'Stateful_Builder'">VGLDocumentBuilder: a 'Stateful Builder'</a></div><div style="margin-left: 40px;"><a href="#Handling_Illegal_Builder_Directions">Handling Illegal Builder Directions</a></div><div style="margin-left: 40px;"><a href="#Builder_Context">Builder Context</a></div><div style="margin-left: 40px;"><a href="#Document_Builder_States">Document Builder States</a></div><div style="margin-left: 40px;"><a href="#VGLDocumentLoader">VGLDocumentLoader</a></div></font><br><br><font class="titleText"><a name="Introduction">Introduction</a></font><p><table width="800"><tr><td><font class="normalText">
This package implements two utilities for creating VGL document models: VGLDocumentBuilder, which has a bunch of handy methods for building a VGLDocument, and VGLDocumentLoader, which drives a VGLDocumentBuilder to build a VGLDocument as it parses a VGL XML stream. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Since this package depends upon package vglDocument, this documentation assumes that you have read the documentation for package vglDocument.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
This document might take a couple of reads to follow; you'll probably have to pick your way through the source code as you go to suppliment my description. You should be familiar with the Builder and State patterns. If not, take a look at a book such as 
</font><font class="normalText"><a href="bibliography.html#">[GOF]</a></font></td></tr></table><br><br><br><font class="titleText"><a name="VGLDocumentBuilder:_a_'Stateful_Builder'">VGLDocumentBuilder: a 'Stateful Builder'</a></font><p><table width="800"><tr><td><font class="normalText">
A VGLDocumentBuilder hides the complexity of VGLDocument construction behind a single class API. Since a VGLDocument is a hierarchical data structure, VGLDocumentBuilder operates on a metaphore of nested "opening" and "closing" of document elements; when an element is opened, it's construction begins, then when it's closed, it's construction is finished. If the element is opened inside a parent element, where the parent is still open, the element will be added to it's parent when closed.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Each document element has a subset of the VGLDocumentBuilder direction methods that apply to it, and a subset that do not. For example, between openPolygon and it's corresponding close direction, addVertex is legal, but setCentre is not. In the event of an such an illegal direction being given, VGLDocumentBuilder will log an error message with a user-supplied ErrorHandler and otherwise ignore the direction.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
VGLDocumentBuilder therefore has a number of internal states, each of which has a certain behaviour. This was a clear invitation to apply the State pattern, as will be described. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
AbstractBuilderState declares an abstract base class common to all states of VGLDocumentBuilder. The states are implemented by 
</font></td></tr></table><p><table width="800"><tr><td><ol><li><font class="normalText">BuildingDocument, in which the document is being built,</font></li><li><font class="normalText">BuildingStyle, in which a VGLStyle style definition is being built,</font></li><li><font class="normalText">BuildingPolygon, in which a VGLPolygon element is being built,</font></li><li><font class="normalText">BuildingPath, in which a VGLPath element is being built,</font></li><li><font class="normalText">BuildingText, in which a VGLText element is being built, and</font></li><li><font class="normalText">BuildingCircle, in which a VGLCircle element is being built.</font></li></ol></td></tr></table><p><table width="800"><tr><td><font class="normalText">
A VGLDocumentBuilder maintains in instance of one of these subclasses at any given time to represent the current state during the build process and delegates all directions to it. The subclasses themselves are responsible for returning an instance of the subclass corresponding to the next state after a transition. For example, the openPolygon method of a BuildingDocument will return an instance of a BuildingPolygon. The close method of the BuildingPolygon will return a BuildingDocument to return to it's "parent" state. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Note that the close method of the BuildingDocument will just return the BuildingDocument. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Take a look at the state transition diagram below for a clearer picture of VGLDocumentBuilder states.
</font></td></tr></table><br><br><br><font class="titleText"><a name="Handling_Illegal_Builder_Directions">Handling Illegal Builder Directions</a></font><p><table width="800"><tr><td><font class="normalText">
Note the ErrorHandler which is associated with a VGLDocumentBuilder. A user is required to supply a concrete implementation of this to a VGLDocumentBuilder on instantiation, so that the VGLDocumentBuilder can notify it of any illegal directions.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Any direction method called on AbstractBuilderState results in an error being logged. The subclasses override the direction methods that apply to them, so that an illegal direction, to a method not overridden, will invoke an AbstractBuilderState base method and cause the error to be logged. Note that AbstractBuilderState has a getDescription method which is overidden in each concrete subclass to give a human-readable description of the document element being built by the subclass. When AbstractBuilderState logs an error, it is then able to give informative error messages such as "cannot add a radius to a polygon", where "a polygon" was returned by the current subclass, in this case BuildingPolygon. This is a rather helpful feature if VGLDocumentBuilder's client happens to be a non-validating XML parser.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Each of the state classes are instantiated with a BuildContext and, with the exception of BuildingDocument, a parent state class. When a close direction is given to a state class, it returns it's parent, or if it is a BuildingDocument, it just returns a reference to itself.  
</font></td></tr></table><br><br><br><font class="titleText"><a name="Builder_Context">Builder Context</a></font><p><table width="800"><tr><td><font class="normalText">
The BuildContext supplies resources that are required during the build process. A single instance of BuildContext is owned by a VGLDocumentBuilder. The BuildContext instance is passed between AbstractBuilderState instances as state transitions occur. For example, when VGLDocumentBuilder is initialised (or reset to start a new VGLDocument), it creates itself an instance of BuildingDocument and gives that the BuildContext. On being given an openPolygon direction, BuildingDocument returns a fresh BuildingPolygon instance with the BuildContext plugged into it. The BuildContext has 
</font></td></tr></table><p><table width="800"><tr><td><ol><li><font class="normalText">the VGLDocument being built,</font></li><li><font class="normalText">a table of VGLStyles defined during the build process, registered and accessed by name,</font></li><li><font class="normalText">a Flyweight default VGLStyle instance, and</font></li><li><font class="normalText">an implementation of AbstractVGLFontFactory, which was supplied to the VGLDocumentBuilder on initialisation,</font></li><li><font class="normalText">an ErrorHandler (user-supplied or default) to log errors.</font></li></ol></td></tr></table><p><table width="800"><tr><td><font class="normalText">
When close is called on a state subclass other than BuildingDocument or BuildingStyle, the VGLElement product built by the subclass is inserted into the VGLDocument obtained from the BuildContext. When close is called on a BuildingStyle, the VGLStyle product is registered by name with the BuildContext. When a style is applied to an element with an appropriate subclass's applyStyle method, the style is obtained from the BuildContext to associate with it's VGLElement product.
</font></td></tr></table><br><br><center><img src="figure8.gif"/><br><font class="normalText">Figure 8. Classes implementing the VGL document builder</font></center><br><p><table width="800"><tr><td><font class="normalText">
</font></td></tr></table><br><br><br><font class="titleText"><a name="Document_Builder_States">Document Builder States</a></font><br><br><center><img src="figure9.gif"/><br><font class="normalText">Figure 9. States of the VGL document builder</font></center><br><br><br><br><font class="titleText"><a name="VGLDocumentLoader">VGLDocumentLoader</a></font><p><table width="800"><tr><td><font class="normalText">
A VGLDocumentLoader is given a VGLDocumentBuilder on instantiation. A call to its load method will return a VGLDocument,loaded from the VGL XML source at the specified location. Any parse errors that occur will be handled with the ErrorHandler associated with the VGLDocumentBuilder. Here's a code snippet of the load method, which uses the lightweight XML parser implemented in the NanoXML package:
</font><font class="normalText"><a href="bibliography.html#">[NANO]</a></font></td></tr></table><br><br><span style="font-family: monospace;"><table border="1" width="800" cellpadding="6" cellspacing="0"><tr><td bgcolor="#FFFFDD"><pre>
 public VGLDocument load(String url) throws FileNotFoundException, IOException {
        try {
            IXMLBuilder builder = new VGLXMLBuilder(docBuilder, errorHandler);
            IXMLParser parser = XMLParserFactory.createDefaultXMLParser();
            IXMLReader reader = StdXMLReader.fileReader(url);
            parser.setReader(reader);
            parser.setBuilder(builder);
            parser.parse();
            return docBuilder.buildDocument();
        } catch ...
</pre></td></tr></table></span></br><p><table width="800"><tr><td><font class="normalText">
NanoXMLs IXMLParser parses the VGL XML, and requires a couple of Strategies to help, namely implementations of IXMLBuilder and IXMLReader. The name IXMLBuilder is a bit misleading, because it is really a SAX event handler. VGLXMLBuilder implements an IXMLBuilder, and is given a VGLDocumentBuilder and an ErrorHandler on instantiation. When parsing, the VGLXMLBuilder will translate SAX events into directions for its VGLDocumentBuilder, from which the VGLDocument is got when parsing is complete.
</font></td></tr></table><br><br><br><font class = "subCats"><br></font></td></tr></tbody></table><br></body></html>