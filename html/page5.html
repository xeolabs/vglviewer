<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><title>vglDocument</title><link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style"></head><body><table style="text-align: left; width: 100%; height: 100%;" border="0" cellspacing="0" cellpadding="6"><tbody><tr><td style="text-align: right; background-color: rgb(200, 200, 200);"></td><td class="navGlobal"><font class="navGlobal"><a href="siteIndex.html">Index</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="bibliography.html">Bibliography</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generated by&nbsp;<a href="about/about.html">SiteGen V1.0</a></font></td></tr><tr><td style="text-align: right;  background-color: rgb(0, 0, 0);"><center><img src="logo.gif"/></center></td><td style="height: 100px; vertical-align: bottom; background-color: rgb(255, 255, 100); white-space: nowrap;"><font class="pageTitle">vglDocument</font><br><font class="pageDescription">Implements a VGL document model</font><br><br></td></tr><tr><td class="navTitle"><font class="sectionTitle">Navigation</font></td><td style="vertical-align: top;"><font class="sectionTitle">Document</font></td></tr><tr><td class="navPath"><br><font class="navPrevious"><a href="index.html">VGLViewer</a></font><br><img src="downArrow.gif"/><br><font class="navPrevious"><a href="page1.html">Implementation</a></font><br><img src="downArrow.gif"/><br><font class="navCurrent">vglDocument</font></td><td style = "vertical-align: top;"><br><br><font class="normalText"><div style="margin-left: 40px;"><a href="#Introduction">Introduction</a></div><div style="margin-left: 40px;"><a href="#Document_Model_Architecture">Document Model Architecture</a></div><div style="margin-left: 40px;"><a href="#Windowing_Toolkit_Independence">Windowing Toolkit Independence</a></div><div style="margin-left: 40px;"><a href="#Composition_over_Inheritance">Composition over Inheritance</a></div><div style="margin-left: 40px;"><a href="#Document_Model_Utilities">Document Model Utilities</a></div></font><br><br><font class="titleText"><a name="Introduction">Introduction</a></font><p><table width="800"><tr><td><font class="normalText">
This package implements a VGL document model which is independent of any windowing toolkit with which it might be rendered. A document can
</font></td></tr></table><p><table width="800"><tr><td><ol><li><font class="normalText">contain polygons, paths, circles and text,</font></li><li><font class="normalText">allow you to efficiently access (with a Visitor) elements which intersect a given region,</font></li><li><font class="normalText">be constructed using a builder, and</font></li><li><font class="normalText">be loaded from VGL XML.</font></li></ol></td></tr></table><br><br><br><font class="titleText"><a name="Document_Model_Architecture">Document Model Architecture</a></font><p><table width="800"><tr><td><font class="normalText">
The following class diagram shows the classes which implement vglDocument.
</font></td></tr></table><br><br><center><img src="figure6.gif"/><br><font class="normalText">Figure 6. Classes implementing the VGL document model</font></center><br><p><table width="800"><tr><td><font class="normalText">

VGLDocument models the document itself, which contains a concrete class implementing VGLElement for each element in the document. The concrete element classes are
</font></td></tr></table><p><table width="800"><tr><td><ol><li><font class="normalText">VGLPolygon, which represents a filled polygon,</font></li><li><font class="normalText">VGLPath, which represents an open, unfilled path,</font></li><li><font class="normalText">VGLText, which represents a single line of text, and</font></li><li><font class="normalText">VGLCircle, which represents a filled circle.</font></li></ol></td></tr></table><p><table width="800"><tr><td><font class="normalText">
With each of the element classes is associated with a VGLProperties, which has 
</font></td></tr></table><p><table width="800"><tr><td><ol><li><font class="normalText">a VGLStyle to specify how the element is to appear when rendered,</font></li><li><font class="normalText">an ID to assign to the element, and</font></li><li><font class="normalText">a short textual description of the element.</font></li></ol></td></tr></table><p><table width="800"><tr><td><font class="normalText">
A VGLStyle specifies
</font></td></tr></table><p><table width="800"><tr><td><ol><li><font class="normalText">a colour to which to fill the element,</font></li><li><font class="normalText">a colour with which to draw the edges of the element, and</font></li><li><font class="normalText">a font in which to draw the element.</font></li></ol></td></tr></table><p><table width="800"><tr><td><font class="normalText">
The element will only use VGLStyle properties which apply to it, for example, a VGLPolygon will never use its VGLStyle's font. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
A VGLFont has a user-supplied implementation of AbstractVGLFontMetrics (explained below), which supplies such metrics as the VGLFonts height and width.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
The instance diagram below shows an example of a VGL document model, which contains text, a circle and a polygon. Note how the VGLDocument stores its elements in a BoundaryMap (explained below), and how the text and the the circle share the same style.
</font></td></tr></table><br><br><center><img src="figure7.gif"/><br><font class="normalText">Figure 7. An example document model instance</font></center><br><p><table width="800"><tr><td><font class="normalText">
Now that you know how the document model plugs together, let's take a look at how VGLDocument works.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
VGLElements are added to a VGLDocument with method addElement. A user can then call getElements to visit, with a user-supplied implementation of VGLElementVisitor, VGLElements that intersect a given VGLBoundary. Typically, this would be to render the elements, where the VGLBoundary represents a viewport into the document. Note that VGLElementVisitor is also effectively a Strategy.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
In order to find intersecting elements quickly, VGLDocument stores them in a BoundaryMap (defined in package vgl.boundaryMap). In order to be inserted into the BoundaryMap, VGLElement extends the BoundaryMapElement interface, which requires that the element classes each implement getBoundary to return a Boundary describing their extents. BoundaryUtils is a utility class used by each element class to compute it's Boundary.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
VGLDocument's getElements method will convert it's VGLBoundary parameter to a Boundary for its call to BoundaryMaps getElements method.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
One other BoundaryMapElement interface method is implemented by the element classes: split. This allows the elements to split themselves about a boundary subdivision when required by BoundaryMap. The actual split function is optional, and is implemented by VGLPath, VGLPolygon and VGLCircle, but not by VGLText. See package vgl.boundaryMap for more complete information on this.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
The VGLDocument itself is able to describe the total extents of its VGLElements by providing a VGLBoundary. This is rather useful if we want to render the whole document, scaled to fit some available space perhaps.
</font></td></tr></table><br><br><br><font class="titleText"><a name="Windowing_Toolkit_Independence">Windowing Toolkit Independence</a></font><p><table width="800"><tr><td><font class="normalText">
A VGL document model is designed to be independant of any windowing toolkit (AWT, Swing, SWT etc.) which might be used to render it. This independence was trivial to achieve for everything in the model except for VGLText elements. A VGLText element needs to know the extents of its text in order to compute its Boundary. To enable this, it must be possible to obtain some metrics of its VGLFont (held by the VGLStyle within its VGLProperties). Note that metrics for a given font may well vary between windowing toolkits.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
This problem is solved by leaving it up to the user of package vglDocument to implement AbstractVGLFontMetrics and AbstractVGLFontFactory. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
A VGLFont must be given an implementation of AbstractVGLFontMetrics on instantiation, so that it can provide it when required through its getMetrics method. The users implementation of AbstractVGLFontFactory is expected to generate an instance of AbstractVGLFontMetrics to plug into each VGLFont product that it creates. If you were to use vglDocument with AWT, for example, you might have the newFont method of your AbstractVGLFontFactory implementation
</font></td></tr></table><p><table width="800"><tr><td><ol><li><font class="normalText">create a temporary java.awt.Font to specifications,</font></li><li><font class="normalText">create a java.awt.FontMetrics from the Font and some available java.awt.Component,</font></li><li><font class="normalText">wrap the FontMetrics in an implementation of AbstractVGLFontMetrics, then</font></li><li><font class="normalText">return the AbstractVGLFontMetrics implementation.</font></li></ol></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Note that this trick offloads the (potentially complex) job of maintenance or generation of font metrics onto the windowing toolkit. It also allows vglDocument to be more easily ported from Java to C++ (ie. for OpenGL).
</font></td></tr></table><br><br><br><font class="titleText"><a name="Composition_over_Inheritance">Composition over Inheritance</a></font><p><table width="800"><tr><td><font class="normalText">
As an excercise, and in order to demonstrate composition as an alternative to inheritance, I made VGLElement an interface rather than the usual abstract class that this sort of element tends to be. To do this, I took all the stuff which would have been implemented in VGLElement and split it out into a VGLProperties, to be associated with its concrete implementations.
</font></td></tr></table><br><br><br><font class="titleText"><a name="Document_Model_Utilities">Document Model Utilities</a></font><p><table width="800"><tr><td><font class="normalText">
The utils sub-package defines two classes for creating VGLDocuments: VGLDocumentBuilder, which provides a handy bunch of methods for building a VGLDocument, and VGLDocumentLoader, which drives a VGLDocumentBuilder to build a VGLDocument as it parses a VGL XML source. Read about these in the documentation for package vgl.vglDocument.utils.
</font></td></tr></table><br><br><br><font class = "subCats"><br></font></td></tr></tbody></table><br></body></html>