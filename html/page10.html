<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><title>Design Principles</title><link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style"></head><body><table style="text-align: left; width: 100%; height: 100%;" border="0" cellspacing="0" cellpadding="6"><tbody><tr><td style="text-align: right; background-color: rgb(200, 200, 200);"></td><td class="navGlobal"><font class="navGlobal"><a href="siteIndex.html">Index</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="bibliography.html">Bibliography</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generated by&nbsp;<a href="about/about.html">SiteGen V1.0</a></font></td></tr><tr><td style="text-align: right;  background-color: rgb(0, 0, 0);"><center><img src="logo.gif"/></center></td><td style="height: 100px; vertical-align: bottom; background-color: rgb(255, 255, 100); white-space: nowrap;"><font class="pageTitle">Design Principles</font><br><font class="pageDescription">Design principles employed in VGLViewer</font><br><br></td></tr><tr><td class="navTitle"><font class="sectionTitle">Navigation</font></td><td style="vertical-align: top;"><font class="sectionTitle">Document</font></td></tr><tr><td class="navPath"><br><font class="navPrevious"><a href="index.html">VGLViewer</a></font><br><img src="downArrow.gif"/><br><font class="navPrevious"><a href="page1.html">Implementation</a></font><br><img src="downArrow.gif"/><br><font class="navCurrent">Design Principles</font></td><td style = "vertical-align: top;"><br><br><font class="normalText"><div style="margin-left: 40px;"><a href="#Design_Principles">Design Principles</a></div><div style="margin-left: 40px;"><a href="#The_Open_Closed_Principle_(OCP)">The Open Closed Principle (OCP)</a></div><div style="margin-left: 40px;"><a href="#The_Dependency_Inversion_Principle_(DIP)">The Dependency Inversion Principle (DIP)</a></div><div style="margin-left: 40px;"><a href="#The_Interface_Segregation_Principle_(ISP)">The Interface Segregation Principle (ISP)</a></div><div style="margin-left: 40px;"><a href="#The_Acyclic_Dependencies_Principle_(ADP)">The Acyclic Dependencies Principle (ADP)</a></div><div style="margin-left: 40px;"><a href="#The_Stable_Dependencies_Principle_(SDP)">The Stable Dependencies Principle (SDP)</a></div><div style="margin-left: 40px;"><a href="#The_Stable_Abstractions_Principle_(SAP)">The Stable Abstractions Principle (SAP)</a></div><div style="margin-left: 40px;"><a href="#No_Inheritance_for_Implementation">No Inheritance for Implementation</a></div><div style="margin-left: 40px;"><a href="#Liskov_Substition_Principle">Liskov Substition Principle</a></div><div style="margin-left: 40px;"><a href="#Seperation_of_Concerns">Seperation of Concerns</a></div></font><br><br><font class="titleText"><a name="Design_Principles">Design Principles</a></font><p><table width="800"><tr><td><font class="normalText">
Here's a few design principles I've applied in the design of VGLViewer. I'm not going to point out basic principles like "One Responsibility Rule", because I think that following such principles are a given, and are clearly seen in the design. Incidentally, Martin Fowler points out that some of the principles I've followed are not mandatory to follow. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">I'm assuming that at this point you have familiarised yourself with the contents of each package. 
</font></td></tr></table><br><br><br><font class="titleText"><a name="The_Open_Closed_Principle_(OCP)">The Open Closed Principle (OCP)</a></font><p><table width="800"><tr><td><font class="normalText">
This principle states that a module of software should be "open to extension while being closed to change". 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Low-level VGLViewer packages leave it to their higher-level users to implement their application-specific implementation(s) of some key abstract class(es). For example, package vglDocument leaves it to the user (in this case package vglViewer) to implement VGLElementVisitor, AbstractVGLFontMetrics and AbstractVGLFontFactory. We can extend vglViewer to print a VGLDocument by implementing a new kind of VGLElementVisitor, or switch from using AWT to using Swing, without needing to change package vglDocument in any way, by implementing new types of AbstractVGLFontFactory and AbstractVGLFontMetrics.

</font><font class="normalText"><a href="bibliography.html#">[OCP]</a></font></td></tr></table><br><br><br><font class="titleText"><a name="The_Dependency_Inversion_Principle_(DIP)">The Dependency Inversion Principle (DIP)</a></font><p><table width="800"><tr><td><font class="normalText">
Packages that implement high-level policy should not depend upon packages that implement low-level policy. 

</font><font class="normalText"><a href="bibliography.html#">[DIP]</a></font></td></tr></table><p><table width="800"><tr><td><font class="normalText">A high-level policy is one which is less application-dependent than a low-level policy. It is more abstract than the low-level policy. This is analogous to the concept of high-level and low-level programming languages. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
An example of where DIP has been implemented in VGLViewer is in package boundaryMap. This package implements a high level policy with its general KD-Tree algorithm. By offering the abstract BoundaryMapElement for users to implement, it is not concerned with the low-level policy of how BoundaryMap is implements by elements in package vglDocument, such as how they split themselves about a boundary edge when they don't fit neatly in a half-space.
</font></td></tr></table><br><br><br><font class="titleText"><a name="The_Interface_Segregation_Principle_(ISP)">The Interface Segregation Principle (ISP)</a></font><p><table width="800"><tr><td><font class="normalText">
Clients should not be forced to depend upon interfaces that they do not use. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
A good example of where this principle is followed is package vglRenderer. VGLDocumentRenderer could have implemented VGLElementVisitor and visited all its VGLDocuments elements itself. However, this would have exposed all the VGLElementVisitor methods in the VGLDocumentRenderer API, which would not be of any use to the user. Therefore, VGLDocument has a private VGLElementVisitor implementation which it applies to its VGLDocument.

</font><font class="normalText"><a href="bibliography.html#">[ISP]</a></font></td></tr></table><br><br><br><font class="titleText"><a name="The_Acyclic_Dependencies_Principle_(ADP)">The Acyclic Dependencies Principle (ADP)</a></font><p><table width="800"><tr><td><font class="normalText">
Dependencies between packages should be a Directed Acyclic Graph (DAG). 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
As you can see in VGLViewer packages, there are no cyclic dependencies. In this case, the dependencies go across clearly-defined layer (API) boundaries. This allows 
</font></td></tr></table><p><table width="800"><tr><td><ol><li><font class="normalText">re-use of lower-level packages, such as sdaz or boundaryMap, for other things besides rendering VGL,</font></li><li><font class="normalText">you to clearly see what the responsibilities of each package are, and</font></li><li><font class="normalText">easier documentation, where I can require you to read documentation for each package in a particular order and follow references to package documents which you have read earlier, not some time in the future.</font></li></ol></td></tr></table><p><table width="800"><tr><td><font class="normalText">
ADP was enabled in this application through the use of the Adapter design pattern in package vglViewer. For example, vglViewer was able to glue a SDAZDriver to a DocViewPanel by adapting the DocViewPanel to the SDAZSubject interface. Packages like sdaz do not need to know anything about who was using it at higher levels; as mentioned under The Open-Closed Principle, they require instead that high level packages to supply their application-specific implementation(s) of some key abstract class(es). 

</font></td></tr></table><br><br><br><font class="titleText"><a name="The_Stable_Dependencies_Principle_(SDP)">The Stable Dependencies Principle (SDP)</a></font><p><table width="800"><tr><td><font class="normalText">
Dependencies between packages in a design should be in the direction of the stability of the packages, that is, a package should only depend upon packages that are more stable than it is. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Stability of a package is defined as the likelyhood that its API will be changed, either because it is hard to do so, or because change is not likely to be required. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
An example of where SDP is applied is package boundaryMap. Because it follows the Open-Closed Principle by leaving open a way to extend it without needing modifications (via new implementations of the abstract BoundaryMapElement), it is not likely to need any changes to its API. Other higher-level packages, such as vglViewer, can therefore safely depend upon it in the knowledge that its API is not going to change. Another reason why package boundaryMap is not likely to change is because it does not depend upon any other package. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Note that VGLViewer packages form a tree. The stability of a package is proportional to the number of other packages that depend upon it and is inversely proportional to the number of other packages it depends upon. As we move up the acyclic tree of VGLViewer package dependencies, the packages have more dependencies upon lower packages and less dependencies upon them by higher packages. Their stability decreases accordingly. This particular aspect is sometimes called the Stability Principle.

</font><font class="normalText"><a href="bibliography.html#">[SDP]</a></font></td></tr></table><br><br><br><font class="titleText"><a name="The_Stable_Abstractions_Principle_(SAP)">The Stable Abstractions Principle (SAP)</a></font><p><table width="800"><tr><td><font class="normalText">
Packages that are maximally stable should be maximally abstract. Instable packages should be concrete. The abstraction of a package should be in proportion to it's stability. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
In VGLViewer, the lower level packages in the dependency tree are maximally abstract; they require users to supply their application-dependent implementation of certain abstract classes. The lower level packages are also maximally stable since they have less dependencies than higher-level packages (if any). A top-level package such as vglViewer is the least stable, and accordingly has no abstract classes in it.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText"> 

</font><font class="normalText"><a href="bibliography.html#">[SAP]</a></font></td></tr></table><br><br><br><font class="titleText"><a name="No_Inheritance_for_Implementation">No Inheritance for Implementation</a></font><p><table width="800"><tr><td><font class="normalText">
This principle states that one should not extend a class just to benefit from inheriting some of its implementation.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
This is my personal favourite, since I really like composition, especially since design patterns and heuristics show how to compose properly. The only places I have used inheritance for implementation  are 
</font></td></tr></table><p><table width="800"><tr><td><ol><li><font class="normalText">vglViewer, where ViewPanel extends java.awt.Panel, to contain a DocViewPanel and a few buttons, and</font></li><li><font class="normalText">docViewPanel, where DoubleBufferedPanel extends java.awt.Panel and is extended in turn by DocViewPanel.</font></li></ol></td></tr></table><p><table width="800"><tr><td><font class="normalText">
I was happy doing inheritance in these cases because it is the convention when working with java.awt.Panels. Also, DoubleBufferedPanel has a paintBuffer Template Method which must be implemented by DocViewPanel.  
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
As an excercise, and in order to demonstrate composition as an alternative to inheritance, I made VGLElement in package vglDocument an interface rather than the usual abstract class that this sort of element tends to be. To do this, I took all the stuff which would have been implemented in VGLElement and split it out into a VGLProperties, to be associated with its concrete implementations.
</font></td></tr></table><br><br><br><font class="titleText"><a name="Liskov_Substition_Principle">Liskov Substition Principle</a></font><p><table width="800"><tr><td><font class="normalText">
If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behaviour of P is unchanged when o1 is substituted for o2 then S is a subtype of T.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
An example of an application of LSP is in package vglViewer. DocViewMouseListener implements the State design pattern, where it maintains a reference to either a ListeningForMarqueeMouse or a ListeningForSDAZMouse at any given instant, according to it's current state. The reference is of type MouseHandler. Since both these classes implement MouseHandler (with no difference in contract discernable to DocViewListener), DocViewMouseListener can dispatch events it gets to the reference without having to know which of the two concrete classes the reference points to.
</font></td></tr></table><br><br><br><font class="titleText"><a name="Seperation_of_Concerns">Seperation of Concerns</a></font><p><table width="800"><tr><td><font class="normalText">
As Jay Holland puts it, this is the concept of minimizing the overlap of functionality between different parts of a system, where the parts are made as distinct as possible. This allows one to approach problems independently.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
This is demonstrated by the model-view seperation in the VGLViewer architecture. Package vglDocument implements the document model, while package vglRenderer implements a means of rendering it. A benefit of this is that we could could change the way the document model is rendered by implementing a new renderer package, without having to change the way vglDOcument is implemented.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Here's a better example. I originally implemented the VGLDocument to load itself from an XML source using the Interpretor pattern, where the VGLDocuments constructor was given a pre-constructed DOM tree to initialise itself from. The VGLDocument constructor would iterate through second-level DOM nodes; for each recognised node, it would instantiate a corresponding VGLElement implementation and pass the subtree rooted by that node to its constructor, for it to initialise itself from. This was not a seperation of concerns since it tied the document model to a particular XML syntax.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
I seperated the concerns of storing the document model from how it was loaded by implementing VGLDocumentBuilder, which is driven by VGLDocumentLoader. The document model is now not concerned with how it is loaded.
</font></td></tr></table><br><br><br><font class = "subCats"><br></font></td></tr></tbody></table><br></body></html>