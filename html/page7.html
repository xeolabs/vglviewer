<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><title>vglRenderer</title><link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style"></head><body><table style="text-align: left; width: 100%; height: 100%;" border="0" cellspacing="0" cellpadding="6"><tbody><tr><td style="text-align: right; background-color: rgb(200, 200, 200);"></td><td class="navGlobal"><font class="navGlobal"><a href="siteIndex.html">Index</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="bibliography.html">Bibliography</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generated by&nbsp;<a href="about/about.html">SiteGen V1.0</a></font></td></tr><tr><td style="text-align: right;  background-color: rgb(0, 0, 0);"><center><img src="logo.gif"/></center></td><td style="height: 100px; vertical-align: bottom; background-color: rgb(255, 255, 100); white-space: nowrap;"><font class="pageTitle">vglRenderer</font><br><font class="pageDescription">Renders a VGL document</font><br><br></td></tr><tr><td class="navTitle"><font class="sectionTitle">Navigation</font></td><td style="vertical-align: top;"><font class="sectionTitle">Document</font></td></tr><tr><td class="navPath"><br><font class="navPrevious"><a href="index.html">VGLViewer</a></font><br><img src="downArrow.gif"/><br><font class="navPrevious"><a href="page1.html">Implementation</a></font><br><img src="downArrow.gif"/><br><font class="navCurrent">vglRenderer</font></td><td style = "vertical-align: top;"><br><br><font class="normalText"><div style="margin-left: 40px;"><a href="#Overview">Overview</a></div><div style="margin-left: 40px;"><a href="#Implementation">Implementation</a></div><div style="margin-left: 40px;"><a href="#Optimization_#1:_Integer_Arithmetic">Optimization #1: Integer Arithmetic</a></div><div style="margin-left: 40px;"><a href="#Optimization_#2:_Minimising_the_Impact_of_Garbage_Collection_on_Frame_Rate">Optimization #2: Minimising the Impact of Garbage Collection on Frame Rate</a></div></font><br><br><font class="titleText"><a name="Overview">Overview</a></font><p><table width="800"><tr><td><font class="normalText">
Package vglRenderer implements a renderer of VGLDocuments which can be used with any windowing toolkit. The renderer can also draw grid lines behind document features to give an idea of scale.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
 Before use, a VGLDocumentRenderer is configured with
</font></td></tr></table><p><table width="800"><tr><td><ol><li><font class="normalText">a VGLDocument to render,</font></li><li><font class="normalText">a VGLViewport to specify the region of the VGLDocument to render,</font></li><li><font class="normalText">a VGLWindow to specify the region on the graphics device in which to draw corresponding output primitives such as line segments and polygons, and</font></li><li><font class="normalText">an implementation of VGLRenderingStrategy with which to draw the primitives to the graphics device.</font></li></ol></td></tr></table><p><table width="800"><tr><td><font class="normalText">
When render() is subsequently called on the VGLDocumentRenderer, the VGLDocument will be rendered to the device, against a background of grid lines. 
</font></td></tr></table><br><br><br><font class="titleText"><a name="Implementation">Implementation</a></font><p><table width="800"><tr><td><font class="normalText">
Classes implementing the VGL renderer are shown in the class diagram below. 
</font></td></tr></table><br><br><center><img src="figure10.gif"/><br><font class="normalText">Figure 10. vglRenderer classes</font></center><br><p><table width="800"><tr><td><font class="normalText">
VGLDocumentRenderer has a VGLElementRenderer, with which it visits and renders each VGLElement in the VGLDocument, and a VGLGridLines, with which it renders the grid lines. Both of these classes need the VGLViewport and VGLWindow that the VGLDocumentRenderer was configured with, and these are supplied to them via a RenderContext, which also provides convenient methods for these classes to map coordinates from window to viewport-space. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Incidentally, I originally implemented GridLines and VGLElementRenderer as inner classes of VGLDocumentRenderer. This allowed them direct access to the VGLViewport and VGLWindow held by the VGLDocumentRenderer, but caused them to be hidden in the UML class diagram. It also allowed surrupticous coupling, a risky thing. I factored them out as seperate classes so that they would appear in the diagram and could be discussed. To allow this, I created RenderContext so they could each access the VGLViewport and VGLWindow. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Two more classes remain to be described: VGLRenderingStrategy and Constants. 
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">VGLRenderingStrategy, as the name implies, is a Strategy which is to implemented by users of VGLDocumentRenderer to do the low-level drawing of primitives such as lines and polygons. It's contract requires that it be a state machine that renders elements with the last colour or font that it was given. To use VGLDocumentRenderer with the AWT, for example, a user would supply an Adapter object which adapts a java.awt.Graphics context object to VGLRenderContext interface. This technique makes the package portable across many window managers, and allows it's architecture to be implemented in C++ on top of OpenGL, for example.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
Constants simply holds a constant by which the long integer coordinates of VGLElement subclasses are scaled up by before arithmetic, then scaled down by afterward. This is a standard trick to approximate floating-point arithmatic using integers, as explained in more detail below.
</font></td></tr></table><p><table width="800"><tr><td><font class="normalText">
The following instance diagram shows another view of how instances of these classes plug together to form the document renderer.
</font></td></tr></table><br><br><center><img src="figure11.gif"/><br><font class="normalText">Figure 11. Objects implementing the VGL document renderer</font></center><br><br><br><br><font class="titleText"><a name="Optimization_#1:_Integer_Arithmetic">Optimization #1: Integer Arithmetic</a></font><p><table width="800"><tr><td><font class="normalText">
VGLDocumentRenderer avoids the overhead of floating-point arithmetic by doing most calculations using integers. Recall that VGLDocument element geometries are stored as long integers. Floating-point precision is approximated by shifting integer values left before calculations by multiplying them by the amount defined in property SHIFT in class Constants, then shifting the results right afterwards by dividing by the same amount . The following code snippets from RenderContext shows how in one part of the class the viewport-to-window scalling factors are computed and then used in another part to transform X coordinates from viewport-space to window-space. The factors are stored in left-shifted form, so window coordinates needed to be right-shifted after being multipled by them.
</font></td></tr></table><br><br><span style="font-family: monospace;"><table border="1" width="800" cellpadding="6" cellspacing="0"><tr><td bgcolor="#FFFFDD"><pre>
...

double x = ((double)window.xmax - (double)window.xmin) / (viewport.xmax - viewport.xmin);
double y = ((double)window.ymax - (double)window.ymin) / (viewport.ymax - viewport.ymin);
xMap = (long)(x * Constants.SHIFT);
yMap = (long)(y * Constants.SHIFT);

...

public int mapXVToW(long x)
{
	return (int)((window.xmin + (int)((x - viewport.xmin) * xMap)) / Constants.SHIFT);
}

...
</pre></td></tr></table></span></br><br><br><br><font class="titleText"><a name="Optimization_#2:_Minimising_the_Impact_of_Garbage_Collection_on_Frame_Rate">Optimization #2: Minimising the Impact of Garbage Collection on Frame Rate</a></font><p><table width="800"><tr><td><font class="normalText">
VGLDocumentRenderer uses temporary storage for window-space coordinates that have been transformed from viewport-space, and these coordinates are no longer needed after they have been rendered. We don't want the JVM garbage collector to kick in and clean them up after each path or polygon primitive has been rendered, so, as shown in the following code snippets, they are kept in two static arrays, ix and iy, which are expanded as required. 
</font></td></tr></table><br><br><span style="font-family: monospace;"><table border="1" width="800" cellpadding="6" cellspacing="0"><tr><td bgcolor="#FFFFDD"><pre>
...

       	ensureTempPointCapacity(sx.length);

       	for (int i = 0; i < sx.length; i++) {
           	ix[i] = renderContext.mapXVToW(sx[i]);
                iy[i] = renderContext.mapYVToW(sy[i]);
            }
           
      	drawPath(ix, iy, sx.length);
...

private void ensureTempPointCapacity(int nRequired) {
	if (nRequired > ix.length) {
            ix = new int[nRequired];
            iy = new int[nRequired];
	}
}

private static int[] ix = new int[200];
private static int[] iy = new int[200];

...
</pre></td></tr></table></span></br><br><br><br><font class = "subCats"><br></font></td></tr></tbody></table><br></body></html>